#include <GL/glut.h>
#include <iostream>

// Window dimensions
int windowWidth = 500, windowHeight = 500;

// ------------------------------
// Function to set a single pixel with RGB color
void setPixel(int x, int y, float r, float g, float b) {
    glColor3f(r, g, b);         // Set drawing color
    glBegin(GL_POINTS);         // Begin drawing points
    glVertex2i(x, y);           // Draw point at (x, y)
    glEnd();
    glFlush();                  // Ensure the point is rendered immediately
}

// ------------------------------
// Function to get the current color of a pixel at (x, y)
void getPixelColor(int x, int y, float* color) {
    glReadPixels(x, y, 1, 1, GL_RGB, GL_FLOAT, color);  // Reads RGB values into 'color'
}

// ------------------------------
// Compare two colors; returns true if they match exactly
bool isSameColor(float* color1, float* color2) {
    return (color1[0] == color2[0] &&
            color1[1] == color2[1] &&
            color1[2] == color2[2]);
}

// ------------------------------
// 4-connected recursive Flood Fill function
void floodFill(int x, int y, float* oldColor, float* newColor) {
    float currentColor[3];
    getPixelColor(x, y, currentColor);  // Get the color at current pixel

    // If current color matches old color, fill it and recurse
    if (isSameColor(currentColor, oldColor)) {
        setPixel(x, y, newColor[0], newColor[1], newColor[2]);  // Set new color
        // Recursive calls in 4 directions
        floodFill(x + 1, y, oldColor, newColor);
        floodFill(x - 1, y, oldColor, newColor);
        floodFill(x, y + 1, oldColor, newColor);
        floodFill(x, y - 1, oldColor, newColor);
    }
}

// ------------------------------
// Mouse callback function: triggers flood fill on left click
void mouse(int button, int state, int x, int y) {
    if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN) {
        float oldColor[3];                            // Store original color of clicked pixel
        float newColor[3] = {1.0f, 0.0f, 0.0f};        // Red color to fill

        // OpenGL's (0,0) is bottom-left, window's (0,0) is top-left
        getPixelColor(x, windowHeight - y, oldColor);

        // Only fill if current color is different from fill color
        if (!isSameColor(oldColor, newColor)) {
            floodFill(x, windowHeight - y, oldColor, newColor);
        }
    }
}

// ------------------------------
// Display function: draws the initial boundary (square)
void display() {
    glClear(GL_COLOR_BUFFER_BIT);      // Clear the screen

    // Draw a square using a black line loop
    glColor3f(0.0f, 0.0f, 0.0f);       // Black color
    glBegin(GL_LINE_LOOP);
    glVertex2i(100, 100);
    glVertex2i(200, 100);
    glVertex2i(200, 200);
    glVertex2i(100, 200);
    glEnd();

    glFlush();                         // Render the square immediately
}

// ------------------------------
// Initialize OpenGL settings
void init() {
    glClearColor(1.0, 1.0, 1.0, 1.0);   // Set background to white
    glColor3f(0.0, 0.0, 0.0);           // Default drawing color: black
    gluOrtho2D(0, windowWidth, 0, windowHeight);  // Define 2D orthographic view
}

// ------------------------------
// Main function: sets up GLUT and starts the main loop
int main(int argc, char** argv) {
    glutInit(&argc, argv);                             // Initialize GLUT
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);       // Single buffer, RGB color
    glutInitWindowSize(windowWidth, windowHeight);     // Set window size
    glutCreateWindow("Flood Fill in OpenGL");          // Create window

    init();                      // Call initialization
    glutDisplayFunc(display);    // Register display callback
    glutMouseFunc(mouse);        // Register mouse callback
    glutMainLoop();              // Enter the event-processing loop
    return 0;
}
