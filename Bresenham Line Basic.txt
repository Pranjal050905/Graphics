#include <GL/freeglut.h>     // OpenGL Utility Toolkit header for rendering
#include <iostream>          // For input/output
#include <vector>            // For storing major coordinates
#include <cmath>             // For abs() function
using namespace std;

// Global variables to store starting and ending coordinates of the line
int xStart, yStart, xEnd, yEnd;

// Vector to store major 10 coordinates on the line
vector<pair<int, int>> majorCoords;

// Function to plot a pixel at (x, y) and store the point if it's among the first 10
void plot(int x, int y) {
    glBegin(GL_POINTS);         // Begin drawing points
    glVertex2i(x, y);           // Plot point (x, y)
    glEnd();

    // Store the first 10 plotted coordinates
    if (majorCoords.size() < 10)
        majorCoords.push_back(make_pair(x, y));
}

// Bresenham's Line Drawing Algorithm
void bresenhamLineDrawing() {
    int dx = abs(xEnd - xStart);    // Absolute difference in x
    int dy = abs(yEnd - yStart);    // Absolute difference in y

    int x = xStart;                 // Initialize x to start x
    int y = yStart;                 // Initialize y to start y

    // Determine step direction for x and y
    int sx = (xEnd >= xStart) ? 1 : -1;
    int sy = (yEnd >= yStart) ? 1 : -1;

    bool isSteep = dy > dx;        // Check if the line is steep

    // If steep, swap the roles of x and y
    if (isSteep) {
        swap(x, y);
        swap(dx, dy);
        swap(sx, sy);
    }

    int p = 2 * dy - dx;           // Initial decision parameter

    // Loop through each step in x direction
    for (int i = 0; i <= dx; ++i) {
        if (isSteep)
            plot(y, x);           // If steep, plot (y, x)
        else
            plot(x, y);           // Else, plot (x, y)

        x += sx;                  // Increment x by step direction
        if (p >= 0) {             // Decision point check
            y += sy;              // Increment y if decision parameter is positive
            p -= 2 * dx;
        }
        p += 2 * dy;              // Update decision parameter
    }

    glFlush();                    // Flush the OpenGL buffer to ensure drawing

    // Output the first 10 major coordinates
    cout << "Major 10 Coordinates:\n";
    for (int i = 0; i < majorCoords.size(); ++i) {
        cout << "(" << majorCoords[i].first << ", " << majorCoords[i].second << ")\n";
    }
}

// Display callback function for GLUT
void display() {
    glClear(GL_COLOR_BUFFER_BIT);     // Clear the window with background color
    glColor3f(0.0, 0.0, 0.0);         // Set drawing color to black
    bresenhamLineDrawing();          // Call the line drawing function
}

// Initialization function for setting up OpenGL
void init() {
    glClearColor(1.0, 1.0, 1.0, 1.0); // Set background color to white
    gluOrtho2D(0, 500, 0, 500);       // Set 2D orthographic viewing region
}

int main(int argc, char** argv) {
    // Get starting and ending coordinates from user
    cout << "Enter xStart yStart: ";
    cin >> xStart >> yStart;
    cout << "Enter xEnd yEnd: ";
    cin >> xEnd >> yEnd;

    // Initialize GLUT and create window
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);    // Single buffer and RGB color
    glutInitWindowSize(500, 500);                   // Window size
    glutInitWindowPosition(100, 100);               // Window position
    glutCreateWindow("Bresenham Line Drawing");     // Create window with title

    init();                    // Call initialization
    glutDisplayFunc(display); // Set display callback function
    glutMainLoop();           // Enter the GLUT event-processing loop
    return 0;
}
